from hy.core.language import eval
import contextlib


class Py2HyReturnException(Exception):

    def __init__(self, retvalue):
        self.retvalue = retvalue
        return None
import os
import re
import sys
import hy.macros
import hy.compiler
from hy._compat import builtins, string_types
docomplete = True
try:
    import readline
    _hy_anon_var_1 = None
except Py2HyReturnException as e:
    raise e
    _hy_anon_var_1 = None
except ImportError:
    try:
        import pyreadline.rlmain
        import pyreadline.unicode_helper
        import readline
        _hy_anon_var_2 = None
    except Py2HyReturnException as e:
        raise e
        _hy_anon_var_2 = None
    except ImportError:
        docomplete = False
        _hy_anon_var_2 = None
    _hy_anon_var_1 = _hy_anon_var_2
if docomplete:
    if ((sys.platform == 'darwin') and ('libedit' in readline.__doc__)):
        readline_bind = 'bind ^I rl_complete'
        _hy_anon_var_3 = None
    else:
        readline_bind = 'tab: complete'
        _hy_anon_var_3 = None
    _hy_anon_var_4 = _hy_anon_var_3
else:
    _hy_anon_var_4 = None


class Completer(object):

    def __init__(self, namespace={}):
        if (not isinstance(namespace, dict)):
            raise TypeError('namespace must be a dictionary')
            _hy_anon_var_5 = None
        else:
            _hy_anon_var_5 = None
        self.namespace = namespace
        self.path = [hy.compiler._compile_table, builtins.__dict__, hy.macros._hy_macros[None], namespace]
        self.tag_path = [hy.macros._hy_tag[None]]
        if ('__name__' in namespace):
            module_name = namespace['__name__']
            self.path.append(hy.macros._hy_macros[module_name])
            _hy_anon_var_6 = self.tag_path.append(hy.macros._hy_tag[module_name])
        else:
            _hy_anon_var_6 = None
        return None

    def attr_matches(self, text):
        try:
            m = re.match('(\\S+(\\.[\\w-]+)*)\\.([\\w-]*)$', text)
            if m:
                _py2hy_anon_var_G_1236 = m.group(1, 3)
                expr = _py2hy_anon_var_G_1236[0]
                attr = _py2hy_anon_var_G_1236[1]
                attr = attr.replace('-', '_')
                expr = expr.replace('-', '_')
                _hy_anon_var_7 = None
            else:
                raise Py2HyReturnException([])
                _hy_anon_var_7 = None
            try:
                obj = eval(expr, self.namespace)
                words = dir(obj)
                _hy_anon_var_8 = None
            except Py2HyReturnException as e:
                raise e
                _hy_anon_var_8 = None
            except Exception:
                raise Py2HyReturnException([])
                _hy_anon_var_8 = None
            n = len(attr)
            matches = []
            for w in words:
                (matches.append('{}.{}'.format(expr.replace('_', '-'), w.replace('_', '-'))) if (w[slice(None, n, None)] == attr) else None)
            raise Py2HyReturnException(matches)
            _hy_anon_var_9 = None
        except Py2HyReturnException as e:
            _hy_anon_var_9 = e.retvalue
        return _hy_anon_var_9

    def global_matches(self, text):
        matches = []
        for p in self.path:
            for k in p.keys():
                if isinstance(k, string_types):
                    k = k.replace('_', '-')
                    _hy_anon_var_10 = (matches.append(k) if k.startswith(text) else None)
                else:
                    _hy_anon_var_10 = None
        return matches

    def tag_matches(self, text):
        text = text[slice(1, None, None)]
        matches = []
        for p in self.tag_path:
            for k in p.keys():
                ((matches.append('#{}'.format(k)) if k.startswith(text) else None) if isinstance(k, string_types) else None)
        return matches

    def complete(self, text, state):
        try:
            if text.startswith('#'):
                matches = self.tag_matches(text)
                _hy_anon_var_12 = None
            else:
                if ('.' in text):
                    matches = self.attr_matches(text)
                    _hy_anon_var_11 = None
                else:
                    matches = self.global_matches(text)
                    _hy_anon_var_11 = None
                _hy_anon_var_12 = _hy_anon_var_11
            try:
                raise Py2HyReturnException(matches[state])
                _hy_anon_var_13 = None
            except Py2HyReturnException as e:
                raise e
                _hy_anon_var_13 = None
            except IndexError:
                raise Py2HyReturnException(None)
                _hy_anon_var_13 = None
            _hy_anon_var_14 = _hy_anon_var_13
        except Py2HyReturnException as e:
            _hy_anon_var_14 = e.retvalue
        return _hy_anon_var_14

@contextlib.contextmanager
def completion(completer=None):
    try:
        delims = '()[]{} '
        if (not completer):
            completer = Completer()
            _hy_anon_var_15 = None
        else:
            _hy_anon_var_15 = None
        if docomplete:
            readline.set_completer(completer.complete)
            readline.set_completer_delims(delims)
            history = os.path.expanduser('~/.hy-history')
            readline.parse_and_bind('set blink-matching-paren on')
            try:
                _hy_anon_var_16 = readline.read_history_file(history)
            except Py2HyReturnException as e:
                raise e
                _hy_anon_var_16 = None
            except IOError:
                _hy_anon_var_16 = open(history, 'a').close()
            _hy_anon_var_17 = readline.parse_and_bind(readline_bind)
        else:
            _hy_anon_var_17 = None
        try:
            _hy_anon_var_18 = yield
        except Py2HyReturnException as e:
            raise e
            _hy_anon_var_18 = None
        finally:
            (readline.write_history_file(history) if docomplete else None)
        _hy_anon_var_19 = _hy_anon_var_18
    except Py2HyReturnException as e:
        _hy_anon_var_19 = e.retvalue
    return _hy_anon_var_19
